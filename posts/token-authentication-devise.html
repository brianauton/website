<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta content='IE=edge;chrome=1' http-equiv='X-UA-Compatible'>
    <meta content='width=device-width, initial-scale=1' name='viewport'>
    <title>
      Brian Auton
       - Rails Token Authentication Without Devise
    </title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
    <link href="/stylesheets/all.css" rel="stylesheet" type="text/css" />
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class='body_back'>
      <section class='left_sidebar_content_area'>
        <div class='sidebar_single_module'>
          <div class='sidebar_wraper'>
            <div class='sidebar_inner'>
              <div class='text_widget'>
                <h2>
                  Brian Auton
                </h2>
                <p>Software developer and consultant in the Philadelphia area.</p>
              </div>
              <div class='right_social_area'>
                <br>
                <p>
                  <a class='fa fa-rss' href='/feed.xml'></a>
                  <a class='fa fa-github' href='https://github.com/brianauton'></a>
                  <a class='fa fa-linkedin-square' href='https://linkedin.com/in/brianauton'></a>
                  <a class='fa fa-twitter' href='https://twitter.com/brianauton'></a>
                  <a class='fa fa-envelope-o' href='mailto:brianauton@gmail.com'></a>
                </p>
              </div>
            </div>
          </div>
        </div>
        <div class='sidebar_single_module'>
          <div class='sidebar_wraper'>
            <div class='sidebar_inner'>
              <div class='text_widget'>
                <h2>Recent Posts</h2>
                <p><a href="/posts/rails-web-components-polymer-part-1.html">Rails and Web Components Part 1&#58; Adding Polymer to a Rails App</a></p>
                <p><a href="/posts/best-commit-messages-one-line.html">The Best Commit Messages Are Just One Line</a></p>
                <p><a href="/posts/token-authentication-devise.html">Rails Token Authentication Without Devise</a></p>
              </div>
            </div>
          </div>
        </div>
        <div class='sidebar_single_module'>
          <div class='sidebar_wraper'>
            <div class='sidebar_inner'>
              <div class='text_widget'>
                <h2>Open Source Projects</h2>
                <p>
                  <a href="https://github.com/brianauton/conjure">Conjure</a>
                  Rails provisioning and deployment with the power of Docker.
                </p>
                <p>
                  <a href="https://github.com/brianauton/rails-embryo">Rails-Embryo</a>
                  Generators to quick-start new Rails projects with best practices
                </p>
                <p>
                  <a href="https://github.com/brianauton/rails-futurizer">Rails-Futurizer</a>
                  Helping to smooth the upgrade path for Rails applications.
                </p>
                <p>
                  <a href="https://github.com/brianauton/rspec-contracts">RSpec-Live</a>
                  Auto-runner and formatter for RSpec 3.
                </p>
              </div>
            </div>
          </div>
        </div>
        <div class='sidebar_single_module'>
          <div class='sidebar_wraper'>
            <div class='sidebar_inner'>
              <div class='text_widget copy_right'>
                <h2>&copy; 2014 Brian Auton</h2>
              </div>
            </div>
          </div>
        </div>
      </section>
      <div class='main_content_area'>
        <div id='expand_content_menu'>
          <span class='icon icon-fontawesome-webfont-1'></span>
        </div>
        <div id='body_hover'></div>
        <section class='profile_area small'>
          <div class='container'>
            <div class='row'>
              <div class='profile_inner'>
                <div class='col-xs-5 col-sm-5 col-md-5 col-lg-5' style='text-align: right'>
                  <div class='profile_picture'>
                    <a href='/'>
                      <img alt='title' src='/images/headshot.png'>
                    </a>
                  </div>
                </div>
                <div class='col-xs-7 col-sm-7 col-md-7 col-lg-7' style='text-align: left'>
                  <h2>
                    <a href='/'>Brian Auton</a>
                  </h2>
                </div>
              </div>
            </div>
          </div>
        </section>
        <section class='home_page_post_area'>
          <div class='container'>
            <div class='row'>
              <div class='col-md-12'>
                <div class='home_single_post'>
                  <div class='post_content_area'>
                    <div class='row'>
                      <div class='col-xs-12 col-sm-8 col-md-8 col-lg-8 col-xs-offset-0 col-sm-offset-2 col-md-offset-2 col-lg-offset-2'>
                        <div class='single_post_content'>
                          <h2><a href="/posts/token-authentication-devise.html">Rails Token Authentication Without Devise</a></h2>
                          <div class='post_info'>
                            <div class='date_area'>
                              <br>
                              <a href="#">by Brian Auton,</a>
                              <a href="#">May  4 2014</a>
                              <br>
                            </div>
                          </div>
                          <blockquote>
                          <p>A popular solution for token-based authentication in Rails has been
                          retired, and the most common replacements leave some security issues
                          unaddressed.  Here&rsquo;s a solution with a clean and maintainable design.</p>
                          </blockquote>
                          
                          <p>Anyone working on a modern Rails application is probably familiar with
                          <a href="https://github.com/plataformatec/devise">Devise</a>. It&rsquo;s by far the <a href="https://www.ruby-toolbox.com/categories/rails_authentication">most popular</a> drop-in solution for handling
                          authentication of the username and password variety. Anyone who also
                          needs to offer token-based authentication (maybe in order to offer a
                          REST API), might be accustomed to using Devise for this too, through
                          its handy <code>token_authenticatable</code> feature.</p>
                          
                          <p>Those developers might be dismayed, as I was, to find that
                          <code>token_authenticatable</code> has been <a href="https://github.com/plataformatec/devise/issues/2616">removed</a> from recent versions of
                          Devise. They might be further dismayed to find that the only solution
                          that has any sort of consensus as a replacement seems dubious for a
                          couple of different reasons.
                          </p>
                          
                          <h4>The Problem and Solutions So Far</h4>
                          
                          <p>Why was <code>token_authenticatable</code> removed? According to the <a href="http://blog.plataformatec.com.br/2013/08/devise-3-1-now-with-more-secure-defaults/">official
                          blog post</a>, the concern was raised that authentication tokens (along
                          with other non-password secrets like password reset tokens) have
                          traditionally been stored in plain text by Devise, and as such are
                          vulnerable to timing attacks. This is true, and they are also
                          vulnerable to brute-force cracking attempts, as well as being
                          completely exposed in the event of unauthorized read access to the
                          database.</p>
                          
                          <p>Of course, all these issues have been long known as they pertain to
                          the traditional user passwords that are at the core of Devise&rsquo;s
                          functionality. That&rsquo;s why Devise has always run these passwords
                          through a <a href="http://throwingfire.com/storing-passwords-securely/#notpasswordhashes">password hash function</a> before storing them in the
                          database. A good password hash function, such as the widely-trusted
                          <a href="https://github.com/codahale/bcrypt-ruby">bcrypt</a> that Devise uses by default, solves all these problems at
                          once, and there&rsquo;s very little reason not to use one when handling any
                          data that is used as a password.</p>
                          
                          <p>As of version 3.1, Devise began protecting most of its non-password
                          secrets by hashing them with bcrypt as well. But hashing an
                          authentication token that&rsquo;s intended for repeated use presents a
                          couple of extra challenges. For one, if bcrypt authentication needs to
                          be performed on every request to an API, the extra performance penalty
                          could result in a significant slowdown. Also, the user experience
                          around API-enabled websites is often designed so that a user can
                          retreive their API token if they&rsquo;ve forgotten it, which is impossible
                          if the token is only stored as a hash.</p>
                          
                          <p>The Devise team decided not to impose a single solution to these
                          problems on everyone who uses Devise for token
                          authentication. Instead, they removed the feature and linked to a
                          <a href="https://gist.github.com/josevalim/fb706b1e933ef01e4fb6">gist</a> that presents two different code samples as starting points for
                          a custom solution to the problem. One of these is equivalent to
                          Devise&rsquo;s old behavior, and the other one adds some protection against
                          timing attacks at the expense of changing the application API and
                          requiring additional info from the users who are authenticating via
                          token.</p>
                          
                          <p>On the plus side, this approach encourages users to think through the
                          solution as it applies to their individual applications, rather than
                          blindly copying code. On the other hand, it still amounts to the
                          strongly discouraged practice of <a href="http://security.stackexchange.com/a/18198">rolling one&rsquo;s own</a> security
                          code. Furthermore, the provided &ldquo;secure&rdquo; option only addresses the
                          timing attack problem, while continuing to store authentication
                          secrets in plain text and thus remaining exposed to the other
                          vulnerabilities.</p>
                          
                          <h4>An Alternate Solution</h4>
                          
                          <p>When facing these issues recently on a new API-focused application, I
                          found some opportunities to improve on the solution suggested by the
                          Devise team. Most importantly, I thought it was worth finding a way
                          around the performance and token-recoverability issues mentioned
                          above, to gain the benefit of using bcrypt to hash authentication
                          tokens. In addition to protecting against more vulnerabilities than
                          just timing attacks, this also means that while the overall security
                          architecture is hand-rolled, the most critical hashing and comparison
                          code is handed off to a trusted library.</p>
                          
                          <p>In addition, I ended up with a solution that has a more modular and
                          maintainable design for the data model, and that&rsquo;s easily adaptable to
                          applications not using Devise. Let&rsquo;s walk through the solution below;
                          feel free to make use of it and make suggestions for further
                          improvement.</p>
                          
                          <h4>Storing the Secret</h4>
                          
                          <p>It&rsquo;s common practice to add additional authentication-related fields
                          to the application&rsquo;s User model, but let&rsquo;s defy that trend and create
                          a separate AuthenticationToken model. This will avoid conflicting with
                          any fields already on User, but more importantly, it decouples the
                          User model from the token authentication logic. This is very good for
                          maintainability, because changes to the authentication scheme won&rsquo;t
                          require changes to the User model (or models, as the case may be).</p>
                          
                          <p>It&rsquo;s also good because it&rsquo;s flexible enough to allow multiple
                          AuthenticationTokens for each User. Later we&rsquo;ll discuss one reason why
                          we might want that. But for now, it means that we can&rsquo;t rely on a
                          User-specific piece of data (such as email address, as in the Devise
                          example) to uniquely identify the token value (which we&rsquo;ll call the
                          <code>secret</code>) that we hashed with bcrypt. So we&rsquo;ll need some kind of
                          searchable unique token identifier stored in plain text, and we&rsquo;ll
                          call that the <code>secret_id</code>. AWS users are used to keeping track of both
                          a &ldquo;key id&rdquo; and a &ldquo;secret key&rdquo; for exactly this reason.</p>
                          
                          <p>As long as we&rsquo;re aiming for a modular design, we should also make the
                          user-to-token relationship polymorphic, so we&rsquo;ll only need one token
                          model in applications that have multiple user models (to which we&rsquo;ll
                          give the general label <code>authenticatable</code>). With all that in mind,
                          here&rsquo;s the migration for the token model:</p>
                          <pre class="highlight ruby"><span class="k">class</span> <span class="nc">CreateAuthenticationTokens</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>&#x000A;  <span class="k">def</span> <span class="nf">change</span>&#x000A;    <span class="n">create_table</span> <span class="ss">:authentication_tokens</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>&#x000A;      <span class="n">t</span><span class="p">.</span><span class="nf">references</span> <span class="ss">:authenticatable</span><span class="p">,</span> <span class="ss">polymorphic: </span><span class="kp">true</span>&#x000A;      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:secret_id</span>&#x000A;      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:hashed_secret</span>&#x000A;      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>&#x000A;    <span class="k">end</span>&#x000A;    <span class="n">add_index</span> <span class="ss">:authentication_tokens</span><span class="p">,</span> <span class="ss">:secret_id</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span></pre>
                          
                          <h4>The Model</h4>
                          
                          <p>The <code>secret_id</code> and <code>hashed_secret</code> go in the database, while the
                          plaintext <code>secret</code> is only stored in memory. We need code in our
                          AuthenticationToken model to generate all three of these values, and
                          also code to perform the actual authentication by finding a token that
                          matches the <code>secret</code> and <code>secret_id</code> from a user request.</p>
                          
                          <p>We&rsquo;ll make the
                          AuthenticationToken generate all three of these values before
                          validation any time they don&rsquo;t exist, which ensures that they&rsquo;ll exist
                          on newly-created tokens after saving. Here&rsquo;s the code for our
                          AuthenticationToken model:</p>
                          <pre class="highlight ruby"><span class="nb">require</span> <span class="s2">"securerandom"</span>&#x000A;<span class="nb">require</span> <span class="s2">"bcrypt"</span>&#x000A;&#x000A;<span class="k">class</span> <span class="nc">AuthenticationToken</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>&#x000A;  <span class="n">belongs_to</span> <span class="ss">:authenticatable</span><span class="p">,</span> <span class="ss">polymorphic: </span><span class="kp">true</span>&#x000A;  <span class="n">validates</span> <span class="ss">:secret_id</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">uniqueness: </span><span class="kp">true</span>&#x000A;  <span class="n">validates</span> <span class="ss">:hashed_secret</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>&#x000A;  <span class="n">before_validation</span> <span class="ss">:generate_secret_id</span><span class="p">,</span> <span class="k">unless</span><span class="p">:</span> <span class="ss">:secret_id</span>&#x000A;  <span class="n">before_validation</span> <span class="ss">:generate_secret</span><span class="p">,</span> <span class="k">unless</span><span class="p">:</span> <span class="ss">:secret</span>&#x000A;  <span class="kp">attr_accessor</span> <span class="ss">:secret</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">find_authenticated</span> <span class="n">credentials</span>&#x000A;    <span class="n">token</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="ss">secret_id: </span><span class="n">credentials</span><span class="o">[</span><span class="ss">:secret_id</span><span class="o">]</span><span class="p">).</span><span class="nf">first</span>&#x000A;    <span class="n">token</span> <span class="k">if</span> <span class="n">token</span> <span class="o">&amp;&amp;</span> <span class="n">token</span><span class="p">.</span><span class="nf">has_secret?</span><span class="p">(</span><span class="n">credentials</span><span class="o">[</span><span class="ss">:secret</span><span class="o">]</span><span class="p">)</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">has_secret?</span> <span class="n">secret</span>&#x000A;    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">hashed_secret</span><span class="p">)</span> <span class="o">==</span> <span class="n">secret</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="kp">private</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">generate_secret_id</span>&#x000A;    <span class="k">begin</span>&#x000A;      <span class="nb">self</span><span class="p">.</span><span class="nf">secret_id</span> <span class="o">=</span> <span class="no">SecureRandom</span><span class="p">.</span><span class="nf">hex</span> <span class="mi">8</span>&#x000A;    <span class="k">end</span> <span class="k">while</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">secret_id: </span><span class="nb">self</span><span class="p">.</span><span class="nf">secret_id</span><span class="p">)</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">generate_secret</span>&#x000A;    <span class="nb">self</span><span class="p">.</span><span class="nf">secret</span> <span class="o">=</span> <span class="no">SecureRandom</span><span class="p">.</span><span class="nf">urlsafe_base64</span> <span class="mi">32</span>&#x000A;    <span class="nb">self</span><span class="p">.</span><span class="nf">hashed_secret</span> <span class="o">=</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="p">.</span><span class="nf">create</span> <span class="n">secret</span><span class="p">,</span> <span class="ss">cost: </span><span class="n">cost</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">cost</span>&#x000A;    <span class="no">Rails</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">test?</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">10</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span></pre>
                          
                          <p>To authenticate, we&rsquo;ll just search for a token matching the given
                          <code>secret_id</code>, and then ask bcrypt to compare its <code>hashed_secret</code> against
                          the secret provided by the user. The result will be the matching
                          AuthenticationToken object, or nil if there&rsquo;s no match. Next, we just
                          need a couple of private methods to generate the secret and secret_id.</p>
                          
                          <p>We also have code to generate the all the necessary secret-related
                          values at validation time. This ensures that when we save a
                          newly-created AuthenticationToken, it will have all the necessary
                          values (the plaintext <code>secret</code> will only be in memory, while the
                          <code>secret_id</code> and <code>hashed_secret</code> will get saved to the database).  We can
                          use Ruby&rsquo;s handy SecureRandom to generate both the secret and the
                          <code>secret_id</code>, and we&rsquo;ll give the <code>secret</code> considerably more entropy to make
                          sure it&rsquo;s secure. We also insert a little extra-paranoid protection
                          when generating the <code>secret_id</code>, to make sure it&rsquo;s unique.</p>
                          
                          <p>Why does the <code>secret_id</code> need any entropy at all? In fact, why not just
                          use AuthenticationToken&rsquo;s existing <code>id</code> field? Because although it
                          suits our purposes by being unique, it also gives away information
                          about the chronological sequence of token creation and the total
                          number of tokens in our database. This information may or may not be
                          useful to potential attackers, but in general it&rsquo;s not the business of
                          anyone who hasn&rsquo;t authenticated.</p>
                          
                          <p>Finally, we confront the API performance issue by carefully choosing
                          the <code>cost</code> value to pass in to bcrypt. In test mode, we want to use
                          the smallest value possible so our automated tests can generate and
                          authenticate tokens quickly. In production we&rsquo;re starting with the
                          same default of 10 that Devise uses, but we&rsquo;re free to turn it up for
                          extra security, or down for faster performance. If we turn it down all
                          the way to 1 for a negligible performance overhead in production,
                          we&rsquo;ll still have hashed secrets that are much more secure than plain
                          text.</p>
                          
                          <h4>The Controller</h4>
                          
                          <p>It&rsquo;s common with or without Devise to have a <code>current_user</code> method in
                          the controller to represent the logged-in user. We&rsquo;ll follow that
                          convention and add a <code>current_token</code> method that holds an
                          AuthenticationToken, if any is currently authenticated. Then the
                          controller can check for a <code>current_token</code> on each request, and
                          automatically log in any associated user. Here&rsquo;s the code to be added
                          to ApplicationController:</p>
                          <pre class="highlight ruby"><span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span>&#x000A;  <span class="n">before_filter</span> <span class="ss">:authenticate_from_token</span>&#x000A;&#x000A;  <span class="kp">protected</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">authenticate_from_token</span>&#x000A;    <span class="k">if</span> <span class="n">current_token</span><span class="p">.</span><span class="nf">try</span> <span class="ss">:authenticatable</span>&#x000A;      <span class="n">sign_in</span> <span class="n">token</span><span class="p">.</span><span class="nf">authenticatable</span><span class="p">,</span> <span class="ss">store: </span><span class="kp">false</span>&#x000A;    <span class="k">end</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">current_token</span>&#x000A;    <span class="no">AuthenticationToken</span><span class="p">.</span><span class="nf">find_authenticated</span><span class="p">({</span>&#x000A;      <span class="ss">secret: </span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:secret</span><span class="o">]</span> <span class="o">||</span> <span class="n">request</span><span class="p">.</span><span class="nf">headers</span><span class="o">[</span><span class="ss">:secret</span><span class="o">]</span><span class="p">),</span>&#x000A;      <span class="ss">secret_id: </span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:secret_id</span><span class="o">]</span> <span class="o">||</span> <span class="n">request</span><span class="p">.</span><span class="nf">headers</span><span class="o">[</span><span class="ss">:secret_id</span><span class="o">]</span><span class="p">),</span>&#x000A;    <span class="p">})</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span></pre>
                          
                          <p>The <code>current_token</code> method includes the logic to find the credentials
                          being submitted by the user. Here, it&rsquo;s set up to recognize
                          credentials in either the params or the request headers, although that
                          policy can easily be customized.</p>
                          
                          <p>The <code>authenticate_from_token</code> method might also need to be modified
                          for different applications. The example above assumes Devise is
                          present, so it uses Devise&rsquo;s <code>sign_in</code> method to sign in the user and
                          set <code>current_user</code>. The <code>store: false</code> option prevents the user&rsquo;s
                          identity from being saved in the session, so subsequent API requests
                          will still require the <code>secret</code> and <code>secret_id</code>. This code could be
                          easily modified to directly set <code>current_user</code>, or whatever is most
                          appropriate for an application not using Devise.</p>
                          
                          <h4>Communicating Secrets to the User</h4>
                          
                          <p>Each user has to know his/her secret_id and secret in order to log
                          in. How to best communicate these credentials to users depends on the
                          needs of your particular application. Some applications might allow
                          users to view their API credentials from a web page. Others might only
                          send the credentials via email, or in response to other API calls
                          (such as those that create new user accounts).</p>
                          
                          <p>Note, however, that since we&rsquo;re hashing our secrets, the only time we
                          can show the user a secret is at the time it is first created. There&rsquo;s
                          no way for a user to come back later and ask for a secret that&rsquo;s been
                          forgotten. This is better for security, but it needs to be anticipated
                          by the UI design of our application. Some services handle this by
                          requiring the API token to be replaced (and any existing token
                          invalidated) any time the user needs to retrieve it, but our decoupled
                          design allows you to create multiple valid tokens for each user if you
                          want. Whatever solution you plan to implement, you can use the console
                          to verify that it&rsquo;s easy to retrieve the credentials of a
                          newly-created token:</p>
                          <pre class="highlight plaintext">$ rake db:migrate &amp;&amp; rails console&#x000A;&gt; token = AuthenticationToken.create; [token.secret_id, token.secret]&#x000A; ...&#x000A; =&gt; ["42aa20ee181a2201", "hWIW41mF1wvvN_3TC5ObaFXBrdWPdEJBWjnGduuGwmA"]</pre>
                          
                          <p>But when the same token is freshly loaded from the database,
                          its secret is unknown.</p>
                          <pre class="highlight plaintext">&gt; token = AuthenticationToken.find(token.id); [token.secret_id, token.secret]&#x000A; ...&#x000A; =&gt; ["42aa20ee181a2201", nil]</pre>
                          
                          <h4>Conclusion</h4>
                          
                          <p>The above code comes with no guarantee of security, and you should use
                          it (along with any modifications you make to suit your own
                          application) with caution, especially because it hasn&rsquo;t been vetted by
                          real-world use. But since it&rsquo;s built around a core of bcrypt, and it
                          aims for a decoupled, maintainable object-oriented design, it should
                          be a good starting point for a post-Devise solution for token
                          authentication. Try it on for size, and let me know what you think.</p>
                          <div id="disqus_thread"></div>
                                      <script type="text/javascript">
                                      //<![CDATA[
                                          (function() {
                                              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                                              dsq.src = '//brianauton.disqus.com/embed.js';
                                              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                                          })();
                                      //]]>
                                      </script>
                                      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                                      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                                  </script>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>
      </div>
    </div>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(["_setAccount", "UA-8088357-1"]);
      _gaq.push(["_trackPageview"]);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? '//ssl' : '//www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <script src="/javascripts/all.js" type="text/javascript"></script>
  </body>
</html>
