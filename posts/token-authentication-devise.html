<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta content='IE=edge;chrome=1' http-equiv='X-UA-Compatible'>
    <meta content='width=device-width, initial-scale=1' name='viewport'>
    <title>
      Brian Auton
       - Rails Token Authentication Without Devise
    </title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
    <link href="/stylesheets/all.css" rel="stylesheet" type="text/css" />
    <script src="/javascripts/all.js" type="text/javascript"></script>
  </head>
  <body>
    <div class='container-fluid'>
      <div class='row'>
        <div class='col-md-7 col-md-offset-1'>
          <h3><a href="/posts/token-authentication-devise.html">Rails Token Authentication Without Devise</a></h3>
          <div class='article-byline'>
            by Brian Auton,
            May  4 2014
          </div>
          <blockquote>
          <p>A popular solution for token-based authentication in Rails has been
          retired, and the most common replacements leave some security issues
          unaddressed.  Here&rsquo;s a solution with a clean and maintainable design.</p>
          </blockquote>
          
          <p>Anyone working on a modern Rails application is probably familiar with
          <a href="https://github.com/plataformatec/devise">Devise</a>. It&rsquo;s by far the <a href="https://www.ruby-toolbox.com/categories/rails_authentication">most popular</a> drop-in solution for handling
          authentication of the username and password variety. Anyone who also
          needs to offer token-based authentication (maybe in order to offer a
          REST API), might be accustomed to using Devise for this too, through
          its handy <code>token_authenticatable</code> feature.</p>
          
          <p>Those developers might be dismayed, as I was, to find that
          <code>token_authenticatable</code> has been <a href="https://github.com/plataformatec/devise/issues/2616">removed</a> from recent versions of
          Devise. They might be further dismayed to find that the only solution
          that has any sort of consensus as a replacement seems dubious for a
          couple of different reasons.</p>
          
          <p></p>
          
          <h4>The Problem and Solutions So Far</h4>
          
          <p>Why was <code>token_authenticatable</code> removed? According to the <a href="http://blog.plataformatec.com.br/2013/08/devise-3-1-now-with-more-secure-defaults/">official
          blog post</a>, the concern was raised that authentication tokens (along
          with other non-password secrets like password reset tokens) have
          traditionally been stored in plain text by Devise, and as such are
          vulnerable to timing attacks. This is true, and they are also
          vulnerable to brute-force cracking attempts, as well as being
          completely exposed in the event of unauthorized read access to the
          database.</p>
          
          <p>Of course, all these issues have been long known as they pertain to
          the traditional user passwords that are at the core of Devise&rsquo;s
          functionality. That&rsquo;s why Devise has always run these passwords
          through a <a href="http://throwingfire.com/storing-passwords-securely/#notpasswordhashes">password hash function</a> before storing them in the
          database. A good password hash function, such as the widely-trusted
          <a href="https://github.com/codahale/bcrypt-ruby">bcrypt</a> that Devise uses by default, solves all these problems at
          once, and there&rsquo;s very little reason not to use one when handling any
          data that is used as a password.</p>
          
          <p>As of version 3.1, Devise began protecting most of its non-password
          secrets by hashing them with bcrypt as well. But hashing an
          authentication token that&rsquo;s intended for repeated use presents a
          couple of extra challenges. For one, if bcrypt authentication needs to
          be performed on every request to an API, the extra performance penalty
          could result in a significant slowdown. Also, the user experience
          around API-enabled websites is often designed so that a user can
          retreive their API token if they&rsquo;ve forgotten it, which is impossible
          if the token is only stored as a hash.</p>
          
          <p>The Devise team decided not to impose a single solution to these
          problems on everyone who uses Devise for token
          authentication. Instead, they removed the feature and linked to a
          <a href="https://gist.github.com/josevalim/fb706b1e933ef01e4fb6">gist</a> that presents two different code samples as starting points for
          a custom solution to the problem. One of these is equivalent to
          Devise&rsquo;s old behavior, and the other one adds some protection against
          timing attacks at the expense of changing the application API and
          requiring additional info from the users who are authenticating via
          token.</p>
          
          <p>On the plus side, this approach encourages users to think through the
          solution as it applies to their individual applications, rather than
          blindly copying code. On the other hand, it still amounts to the
          strongly discouraged practice of <a href="http://security.stackexchange.com/a/18198">rolling one&rsquo;s own</a> security
          code. Furthermore, the provided &ldquo;secure&rdquo; option only addresses the
          timing attack problem, while continuing to store authentication
          secrets in plain text and thus remaining exposed to the other
          vulnerabilities.</p>
          
          <h4>An Alternate Solution</h4>
          
          <p>When facing these issues recently on a new API-focused application, I
          found some opportunities to improve on the solution suggested by the
          Devise team. Most importantly, I thought it was worth finding a way
          around the performance and token-recoverability issues mentioned
          above, to gain the benefit of using bcrypt to hash authentication
          tokens. In addition to protecting against more vulnerabilities than
          just timing attacks, this also means that while the overall security
          architecture is hand-rolled, the most critical hashing and comparison
          code is handed off to a trusted library.</p>
          
          <p>In addition, I ended up with a solution that has a more modular and
          maintainable design for the data model, and that&rsquo;s easily adaptable to
          applications not using Devise. Let&rsquo;s walk through the solution below;
          feel free to make use of it and make suggestions for further
          improvement.</p>
          
          <h4>Storing the Secret</h4>
          
          <p>It&rsquo;s common practice to add additional authentication-related fields
          to the application&rsquo;s User model, but let&rsquo;s defy that trend and create
          a separate AuthenticationToken model. This will avoid conflicting with
          any fields already on User, but more importantly, it decouples the
          User model from the token authentication logic. This is very good for
          maintainability, because changes to the authentication scheme won&rsquo;t
          require changes to the User model (or models, as the case may be).</p>
          
          <p>It&rsquo;s also good because it&rsquo;s flexible enough to allow multiple
          AuthenticationTokens for each User. Later we&rsquo;ll discuss one reason why
          we might want that. But for now, it means that we can&rsquo;t rely on a
          User-specific piece of data (such as email address, as in the Devise
          example) to uniquely identify the token value (which we&rsquo;ll call the
          <code>secret</code>) that we hashed with bcrypt. So we&rsquo;ll need some kind of
          searchable unique token identifier stored in plain text, and we&rsquo;ll
          call that the <code>secret_id</code>. AWS users are used to keeping track of both
          a &ldquo;key id&rdquo; and a &ldquo;secret key&rdquo; for exactly this reason.</p>
          
          <p>As long as we&rsquo;re aiming for a modular design, we should also make the
          user-to-token relationship polymorphic, so we&rsquo;ll only need one token
          model in applications that have multiple user models (to which we&rsquo;ll
          give the general label <code>authenticatable</code>). With all that in mind,
          here&rsquo;s the migration for the token model:</p>
          <pre class="highlight ruby"><span class="k">class</span> <span class="nc">CreateAuthenticationTokens</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>&#x000A;  <span class="k">def</span> <span class="nf">change</span>&#x000A;    <span class="n">create_table</span> <span class="ss">:authentication_tokens</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>&#x000A;      <span class="n">t</span><span class="p">.</span><span class="nf">references</span> <span class="ss">:authenticatable</span><span class="p">,</span> <span class="ss">polymorphic: </span><span class="kp">true</span>&#x000A;      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:secret_id</span>&#x000A;      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:hashed_secret</span>&#x000A;      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>&#x000A;    <span class="k">end</span>&#x000A;    <span class="n">add_index</span> <span class="ss">:authentication_tokens</span><span class="p">,</span> <span class="ss">:secret_id</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span></pre>
          
          <h4>The Model</h4>
          
          <p>The <code>secret_id</code> and <code>hashed_secret</code> go in the database, while the
          plaintext <code>secret</code> is only stored in memory. We need code in our
          AuthenticationToken model to generate all three of these values, and
          also code to perform the actual authentication by finding a token that
          matches the <code>secret</code> and <code>secret_id</code> from a user request.</p>
          
          <p>We&rsquo;ll make the
          AuthenticationToken generate all three of these values before
          validation any time they don&rsquo;t exist, which ensures that they&rsquo;ll exist
          on newly-created tokens after saving. Here&rsquo;s the code for our
          AuthenticationToken model:</p>
          <pre class="highlight ruby"><span class="nb">require</span> <span class="s2">"securerandom"</span>&#x000A;<span class="nb">require</span> <span class="s2">"bcrypt"</span>&#x000A;&#x000A;<span class="k">class</span> <span class="nc">AuthenticationToken</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>&#x000A;  <span class="n">belongs_to</span> <span class="ss">:authenticatable</span><span class="p">,</span> <span class="ss">polymorphic: </span><span class="kp">true</span>&#x000A;  <span class="n">validates</span> <span class="ss">:secret_id</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">uniqueness: </span><span class="kp">true</span>&#x000A;  <span class="n">validates</span> <span class="ss">:hashed_secret</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>&#x000A;  <span class="n">before_validation</span> <span class="ss">:generate_secret_id</span><span class="p">,</span> <span class="k">unless</span><span class="p">:</span> <span class="ss">:secret_id</span>&#x000A;  <span class="n">before_validation</span> <span class="ss">:generate_secret</span><span class="p">,</span> <span class="k">unless</span><span class="p">:</span> <span class="ss">:secret</span>&#x000A;  <span class="kp">attr_accessor</span> <span class="ss">:secret</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">find_authenticated</span> <span class="n">credentials</span>&#x000A;    <span class="n">token</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="ss">secret_id: </span><span class="n">credentials</span><span class="o">[</span><span class="ss">:secret_id</span><span class="o">]</span><span class="p">).</span><span class="nf">first</span>&#x000A;    <span class="n">token</span> <span class="k">if</span> <span class="n">token</span> <span class="o">&amp;&amp;</span> <span class="n">token</span><span class="p">.</span><span class="nf">has_secret?</span><span class="p">(</span><span class="n">credentials</span><span class="o">[</span><span class="ss">:secret</span><span class="o">]</span><span class="p">)</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">has_secret?</span> <span class="n">secret</span>&#x000A;    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">hashed_secret</span><span class="p">)</span> <span class="o">==</span> <span class="n">secret</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="kp">private</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">generate_secret_id</span>&#x000A;    <span class="k">begin</span>&#x000A;      <span class="nb">self</span><span class="p">.</span><span class="nf">secret_id</span> <span class="o">=</span> <span class="no">SecureRandom</span><span class="p">.</span><span class="nf">hex</span> <span class="mi">8</span>&#x000A;    <span class="k">end</span> <span class="k">while</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">secret_id: </span><span class="nb">self</span><span class="p">.</span><span class="nf">secret_id</span><span class="p">)</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">generate_secret</span>&#x000A;    <span class="nb">self</span><span class="p">.</span><span class="nf">secret</span> <span class="o">=</span> <span class="no">SecureRandom</span><span class="p">.</span><span class="nf">urlsafe_base64</span> <span class="mi">32</span>&#x000A;    <span class="nb">self</span><span class="p">.</span><span class="nf">hashed_secret</span> <span class="o">=</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="p">.</span><span class="nf">create</span> <span class="n">secret</span><span class="p">,</span> <span class="ss">cost: </span><span class="n">cost</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">cost</span>&#x000A;    <span class="no">Rails</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">test?</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">10</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span></pre>
          
          <p>To authenticate, we&rsquo;ll just search for a token matching the given
          <code>secret_id</code>, and then ask bcrypt to compare its <code>hashed_secret</code> against
          the secret provided by the user. The result will be the matching
          AuthenticationToken object, or nil if there&rsquo;s no match. Next, we just
          need a couple of private methods to generate the secret and secret_id.</p>
          
          <p>We also have code to generate the all the necessary secret-related
          values at validation time. This ensures that when we save a
          newly-created AuthenticationToken, it will have all the necessary
          values (the plaintext secret will only be in memory, while the
          secret<em>id and hashed</em>secret will get saved to the database).  We can
          use Ruby&rsquo;s handy SecureRandom to generate both the secret and the
          secret<em>id, and we&rsquo;ll give the secret considerably more entropy to make
          sure it&rsquo;s secure. We also insert a little extra-paranoid protection
          when generating the secret</em>id, to make sure it&rsquo;s unique.</p>
          
          <p>Why does the secret_id need any entropy at all? In fact, why not just
          use AuthenticationToken&rsquo;s existing <code>id</code> field? Because although it
          suits our purposes by being unique, it also gives away information
          about the chronological sequence of token creation and the total
          number of tokens in our database. This information may or may not be
          useful to potential attackers, but in general it&rsquo;s not the business of
          anyone who hasn&rsquo;t authenticated.</p>
          
          <p>Finally, we confront the API performance issue by carefully choosing
          the <code>cost</code> value to pass in to bcrypt. In test mode, we want to use
          the smallest value possible so our automated tests can generate and
          authenticate tokens quickly. In production we&rsquo;re starting with the
          same default of 10 that Devise uses, but we&rsquo;re free to turn it up for
          extra security, or down for faster performance. If we turn it down all
          the way to 1 for a negligible performance overhead in production,
          we&rsquo;ll still have hashed secrets that are much more secure than plain
          text.</p>
          
          <h4>The Controller</h4>
          
          <p>It&rsquo;s common with or without Devise to have a <code>current_user</code> method in
          the controller to represent the logged-in user. We&rsquo;ll follow that
          convention and add a <code>current_token</code> method that holds an
          AuthenticationToken, if any is currently authenticated. Then the
          controller can check for a <code>current_token</code> on each request, and
          automatically log in any associated user. Here&rsquo;s the code to be added
          to ApplicationController:</p>
          <pre class="highlight ruby"><span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span>&#x000A;  <span class="n">before_filter</span> <span class="ss">:authenticate_from_token</span>&#x000A;&#x000A;  <span class="kp">protected</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">authenticate_from_token</span>&#x000A;    <span class="k">if</span> <span class="n">current_token</span><span class="p">.</span><span class="nf">try</span> <span class="ss">:authenticatable</span>&#x000A;      <span class="n">sign_in</span> <span class="n">token</span><span class="p">.</span><span class="nf">authenticatable</span><span class="p">,</span> <span class="ss">store: </span><span class="kp">false</span>&#x000A;    <span class="k">end</span>&#x000A;  <span class="k">end</span>&#x000A;&#x000A;  <span class="k">def</span> <span class="nf">current_token</span>&#x000A;    <span class="no">AuthenticationToken</span><span class="p">.</span><span class="nf">find_authenticated</span><span class="p">({</span>&#x000A;      <span class="ss">secret: </span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:secret</span><span class="o">]</span> <span class="o">||</span> <span class="n">request</span><span class="p">.</span><span class="nf">headers</span><span class="o">[</span><span class="ss">:secret</span><span class="o">]</span><span class="p">),</span>&#x000A;      <span class="ss">secret_id: </span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:secret_id</span><span class="o">]</span> <span class="o">||</span> <span class="n">request</span><span class="p">.</span><span class="nf">headers</span><span class="o">[</span><span class="ss">:secret_id</span><span class="o">]</span><span class="p">),</span>&#x000A;    <span class="p">})</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span></pre>
          
          <p>The <code>current_token</code> method includes the logic to find the credentials
          being submitted by the user. Here, it&rsquo;s set up to recognize
          credentials in either the params or the request headers, although that
          policy can easily be customized.</p>
          
          <p>The <code>authenticate_from_token</code> method might also need to be modified
          for different applications. The example above assumes Devise is
          present, so it uses Devise&rsquo;s <code>sign_in</code> method to sign in the user and
          set <code>current_user</code>. The <code>store: false</code> option prevents the user&rsquo;s
          identity from being saved in the session, so subsequent API requests
          will still require the <code>secret</code> and <code>secret_id</code>. This code could be
          easily modified to directly set <code>current_user</code>, or whatever is most
          appropriate for an application not using Devise.</p>
          
          <h4>Communicating Secrets to the User</h4>
          
          <p>Each user has to know his/her secret_id and secret in order to log
          in. How to best communicate these credentials to users depends on the
          needs of your particular application. Some applications might allow
          users to view their API credentials from a web page. Others might only
          send the credentials via email, or in response to other API calls
          (such as those that create new user accounts).</p>
          
          <p>Note, however, that since we&rsquo;re hashing our secrets, the only time we
          can show the user a secret is at the time it is first created. There&rsquo;s
          no way for a user to come back later and ask for a secret that&rsquo;s been
          forgotten. This is better for security, but it needs to be anticipated
          by the UI design of our application. Some services handle this by
          requiring the API token to be replaced (and any existing token
          invalidated) any time the user needs to retrieve it, but our decoupled
          design allows you to create multiple valid tokens for each user if you
          want. Whatever solution you plan to implement, you can use the console
          to verify that it&rsquo;s easy to retrieve the credentials of a
          newly-created token:</p>
          <pre class="highlight plaintext">$ rake db:migrate &amp;&amp; rails console&#x000A;&gt; token = AuthenticationToken.create; [token.secret_id, token.secret]&#x000A; ...&#x000A; =&gt; ["42aa20ee181a2201", "hWIW41mF1wvvN_3TC5ObaFXBrdWPdEJBWjnGduuGwmA"]</pre>
          
          <p>But when the same token is freshly loaded from the database,
          its secret is unknown.</p>
          <pre class="highlight plaintext">&gt; token = AuthenticationToken.find(token.id); [token.secret_id, token.secret]&#x000A; ...&#x000A; =&gt; ["42aa20ee181a2201", nil]</pre>
          
          <h4>Conclusion</h4>
          
          <p>The above code comes with no guarantee of security, and you should use
          it (along with any modifications you make to suit your own
          application) with caution, especially because it hasn&rsquo;t been vetted by
          real-world use. But since it&rsquo;s built around a core of bcrypt, and it
          aims for a decoupled, maintainable object-oriented design, it should
          be a good starting point for a post-Devise solution for token
          authentication. Try it on for size, and let me know what you think.</p>
          <div id="disqus_thread"></div>
                      <script type="text/javascript">
                      //<![CDATA[
                          (function() {
                              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                              dsq.src = '//brianauton.disqus.com/embed.js';
                              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                          })();
                      //]]>
                      </script>
                      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                  </script>
        </div>
        <div class='col-md-3'>
          <div class='well well-sm'>
            <div class='well-title'><a href="/">Brian Auton</a></div>
            <img src='/images/headshot.png'>
            <div class='well-section'>Software developer and consultant in the Philadelphia area.</div>
            <div class='well-section'><a href="https://twitter.com/brianauton/">twitter.com/brianauton</a></div>
            <div class='well-section'><a href="https://linkedin.com/in/brianauton">linkedin.com/in/brianauton</a></div>
            <div class='well-section'><a href="mailto:brianauton@gmail.com">brianauton@gmail.com</a></div>
          </div>
          <div class='well well-sm'>
            <div class='well-title'>Recent Posts</div>
            <div class='well-section'><a href="/posts/token-authentication-devise.html">Rails Token Authentication Without Devise</a></div>
          </div>
          <div class='well well-sm'>
            <div class='well-title'>Open Source Projects</div>
            <div class='well-heading'><a href="https://github.com/brianauton/conjure">Conjure</a></div>
            <div class='well-text'>Rails provisioning and deployment with the power of Docker.</div>
            <div class='well-heading'><a href="https://github.com/brianauton/rails-embryo">Rails-Embryo</a></div>
            <div class='well-text'>A Rails starter project and testing ground for best practices.</div>
            <div class='well-heading'><a href="https://github.com/brianauton/rails-futurizer">Rails-Futurizer</a></div>
            <div class='well-text'>Helping to smooth the upgrade path for Rails applications.</div>
            <div class='well-heading'><a href="https://github.com/brianauton/rspec-contracts">RSpec-Contracts</a></div>
            <div class='well-text'>Automated rigor for unit tests. Still highly experimental.</div>
          </div>
          <div class='copyright'>&copy; 2014 Brian Auton</div>
        </div>
      </div>
    </div>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(["_setAccount", "UA-8088357-1"]);
      _gaq.push(["_trackPageview"]);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? '//ssl' : '//www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>
