<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2014-11-11T19:00:00-05:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>The Best Commit Messages Are Just One Line</title>
    <link rel="alternate" href="http://blog.url.com/posts/best-commit-messages-one-line.html"/>
    <id>http://blog.url.com/posts/best-commit-messages-one-line.html</id>
    <published>2014-11-11T19:00:00-05:00</published>
    <updated>2014-11-22T22:42:50-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;If you want a simple way to make your commit messages more effective, try strictly limiting
them to one line. Many developers and teams try to be helpful by packing extra detail into the
body of each commit message whenever possible. But this detail takes extra time to write and
to read, and it rarely adds any value. Here are some things I&amp;rsquo;ve often seen wasting space in
the body of a multi-line commit message.
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Specific descriptions of changes to the code.&lt;/strong&gt; Anyone who wants more detail about your
commit after seeing it as a one-liner in the commit history will end up looking at the
individual file changes in addition to the commit message. So in a commit whose main purpose
was to “add a User model”, they&amp;rsquo;ll know that you also “added a mirgration” and “added a unit
test.”  There&amp;rsquo;s no need to list those redundant details in the commit message. And there&amp;rsquo;s
always the chance that you&amp;rsquo;ll make a mistake or leave something out, and the resulting
misleading message is worse than no message at all.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notes about follow-on tasks or things that still need to be done.&lt;/strong&gt; &lt;em&gt;“Still need to add
acceptance tests”.&lt;/em&gt; &lt;em&gt;“This should be factored out into a new class”.&lt;/em&gt; If those tasks are
required to finish the current feature, just do them as subsequent commits before you call the
feature done. If they&amp;rsquo;re vital tasks but not part of the current feature, add them to the
project&amp;rsquo;s issue tracking software. After all, no one is combing commit messages for stuff to
do, so you can&amp;rsquo;t leave the completion of a vital feature up to the chance that someone will
notice the reminder in your commit message. If they&amp;rsquo;re not vital, save everyone&amp;rsquo;s time by
leaving them out.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Full URL to the issue tracker software.&lt;/strong&gt; I like commit messages that start with a brief
reference to the issue number itself, mainly because that&amp;rsquo;s a great way to visually group
related commits together. But it becomes tedious to paste a full URL into the commit message
body once you realize that no one has a good reason to follow it. Developers working on the
issue will already have it close at hand. Stakeholders verifying that a feature is complete or
a bug is fixed are looking at the application behavior, not at the commit history. And no one
looking back to your code in the future needs to be distracted by discussions of external
requirements that are now outdated, or alternate approaches that were ultimately abandoned.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Discussion of requirements for the feature.&lt;/strong&gt; &lt;em&gt;“Designer asked for a darker navbar, so we&amp;rsquo;re
trying #000066.”&lt;/em&gt; This is like linking to the issue, but worse, because it pulls irrelevant
discussion out of the issue tracker and directly into the codebase. The commit message should
focus on what was actually done to the code, not what should have been done.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Long descriptions.&lt;/strong&gt; Eliminating all the offenders above leaves what&amp;rsquo;s really important: the
high-level description of what you changed. If this is too long to fit in one line, the
problem may be that your commit is too big. Multiple sentences (as well as multiple clauses
separated by “and”) usually signify separate concerns that should have been committed
separately. If you&amp;rsquo;ve squashed an entire feature branch into a single commit before merging,
stop doing that. Let your commit messages tell a story about how you solved the problem in
individual steps.&lt;/p&gt;

&lt;p&gt;Use appropriate commit sizes and practice revising your wording and eliminating the dead
weight. You can get almost any commit message down to just one line, and each one will add
highly-focused value to the project and make the best use of everyone&amp;rsquo;s time.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rails Token Authentication Without Devise</title>
    <link rel="alternate" href="http://blog.url.com/posts/token-authentication-devise.html"/>
    <id>http://blog.url.com/posts/token-authentication-devise.html</id>
    <published>2014-05-03T20:00:00-04:00</published>
    <updated>2014-11-22T22:51:49-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;A popular solution for token-based authentication in Rails has been
retired, and the most common replacements leave some security issues
unaddressed.  Here&amp;rsquo;s a solution with a clean and maintainable design.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Anyone working on a modern Rails application is probably familiar with
&lt;a href="https://github.com/plataformatec/devise"&gt;Devise&lt;/a&gt;. It&amp;rsquo;s by far the &lt;a href="https://www.ruby-toolbox.com/categories/rails_authentication"&gt;most popular&lt;/a&gt; drop-in solution for handling
authentication of the username and password variety. Anyone who also
needs to offer token-based authentication (maybe in order to offer a
REST API), might be accustomed to using Devise for this too, through
its handy &lt;code&gt;token_authenticatable&lt;/code&gt; feature.&lt;/p&gt;

&lt;p&gt;Those developers might be dismayed, as I was, to find that
&lt;code&gt;token_authenticatable&lt;/code&gt; has been &lt;a href="https://github.com/plataformatec/devise/issues/2616"&gt;removed&lt;/a&gt; from recent versions of
Devise. They might be further dismayed to find that the only solution
that has any sort of consensus as a replacement seems dubious for a
couple of different reasons.
&lt;/p&gt;

&lt;h4&gt;The Problem and Solutions So Far&lt;/h4&gt;

&lt;p&gt;Why was &lt;code&gt;token_authenticatable&lt;/code&gt; removed? According to the &lt;a href="http://blog.plataformatec.com.br/2013/08/devise-3-1-now-with-more-secure-defaults/"&gt;official
blog post&lt;/a&gt;, the concern was raised that authentication tokens (along
with other non-password secrets like password reset tokens) have
traditionally been stored in plain text by Devise, and as such are
vulnerable to timing attacks. This is true, and they are also
vulnerable to brute-force cracking attempts, as well as being
completely exposed in the event of unauthorized read access to the
database.&lt;/p&gt;

&lt;p&gt;Of course, all these issues have been long known as they pertain to
the traditional user passwords that are at the core of Devise&amp;rsquo;s
functionality. That&amp;rsquo;s why Devise has always run these passwords
through a &lt;a href="http://throwingfire.com/storing-passwords-securely/#notpasswordhashes"&gt;password hash function&lt;/a&gt; before storing them in the
database. A good password hash function, such as the widely-trusted
&lt;a href="https://github.com/codahale/bcrypt-ruby"&gt;bcrypt&lt;/a&gt; that Devise uses by default, solves all these problems at
once, and there&amp;rsquo;s very little reason not to use one when handling any
data that is used as a password.&lt;/p&gt;

&lt;p&gt;As of version 3.1, Devise began protecting most of its non-password
secrets by hashing them with bcrypt as well. But hashing an
authentication token that&amp;rsquo;s intended for repeated use presents a
couple of extra challenges. For one, if bcrypt authentication needs to
be performed on every request to an API, the extra performance penalty
could result in a significant slowdown. Also, the user experience
around API-enabled websites is often designed so that a user can
retreive their API token if they&amp;rsquo;ve forgotten it, which is impossible
if the token is only stored as a hash.&lt;/p&gt;

&lt;p&gt;The Devise team decided not to impose a single solution to these
problems on everyone who uses Devise for token
authentication. Instead, they removed the feature and linked to a
&lt;a href="https://gist.github.com/josevalim/fb706b1e933ef01e4fb6"&gt;gist&lt;/a&gt; that presents two different code samples as starting points for
a custom solution to the problem. One of these is equivalent to
Devise&amp;rsquo;s old behavior, and the other one adds some protection against
timing attacks at the expense of changing the application API and
requiring additional info from the users who are authenticating via
token.&lt;/p&gt;

&lt;p&gt;On the plus side, this approach encourages users to think through the
solution as it applies to their individual applications, rather than
blindly copying code. On the other hand, it still amounts to the
strongly discouraged practice of &lt;a href="http://security.stackexchange.com/a/18198"&gt;rolling one&amp;rsquo;s own&lt;/a&gt; security
code. Furthermore, the provided &amp;ldquo;secure&amp;rdquo; option only addresses the
timing attack problem, while continuing to store authentication
secrets in plain text and thus remaining exposed to the other
vulnerabilities.&lt;/p&gt;

&lt;h4&gt;An Alternate Solution&lt;/h4&gt;

&lt;p&gt;When facing these issues recently on a new API-focused application, I
found some opportunities to improve on the solution suggested by the
Devise team. Most importantly, I thought it was worth finding a way
around the performance and token-recoverability issues mentioned
above, to gain the benefit of using bcrypt to hash authentication
tokens. In addition to protecting against more vulnerabilities than
just timing attacks, this also means that while the overall security
architecture is hand-rolled, the most critical hashing and comparison
code is handed off to a trusted library.&lt;/p&gt;

&lt;p&gt;In addition, I ended up with a solution that has a more modular and
maintainable design for the data model, and that&amp;rsquo;s easily adaptable to
applications not using Devise. Let&amp;rsquo;s walk through the solution below;
feel free to make use of it and make suggestions for further
improvement.&lt;/p&gt;

&lt;h4&gt;Storing the Secret&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s common practice to add additional authentication-related fields
to the application&amp;rsquo;s User model, but let&amp;rsquo;s defy that trend and create
a separate AuthenticationToken model. This will avoid conflicting with
any fields already on User, but more importantly, it decouples the
User model from the token authentication logic. This is very good for
maintainability, because changes to the authentication scheme won&amp;rsquo;t
require changes to the User model (or models, as the case may be).&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also good because it&amp;rsquo;s flexible enough to allow multiple
AuthenticationTokens for each User. Later we&amp;rsquo;ll discuss one reason why
we might want that. But for now, it means that we can&amp;rsquo;t rely on a
User-specific piece of data (such as email address, as in the Devise
example) to uniquely identify the token value (which we&amp;rsquo;ll call the
&lt;code&gt;secret&lt;/code&gt;) that we hashed with bcrypt. So we&amp;rsquo;ll need some kind of
searchable unique token identifier stored in plain text, and we&amp;rsquo;ll
call that the &lt;code&gt;secret_id&lt;/code&gt;. AWS users are used to keeping track of both
a &amp;ldquo;key id&amp;rdquo; and a &amp;ldquo;secret key&amp;rdquo; for exactly this reason.&lt;/p&gt;

&lt;p&gt;As long as we&amp;rsquo;re aiming for a modular design, we should also make the
user-to-token relationship polymorphic, so we&amp;rsquo;ll only need one token
model in applications that have multiple user models (to which we&amp;rsquo;ll
give the general label &lt;code&gt;authenticatable&lt;/code&gt;). With all that in mind,
here&amp;rsquo;s the migration for the token model:&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CreateAuthenticationTokens&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Migration&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;change&lt;/span&gt;
    &lt;span class="n"&gt;create_table&lt;/span&gt; &lt;span class="ss"&gt;:authentication_tokens&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
      &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;references&lt;/span&gt; &lt;span class="ss"&gt;:authenticatable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;polymorphic: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
      &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="ss"&gt;:secret_id&lt;/span&gt;
      &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="ss"&gt;:hashed_secret&lt;/span&gt;
      &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;timestamps&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;add_index&lt;/span&gt; &lt;span class="ss"&gt;:authentication_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;unique: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;h4&gt;The Model&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;secret_id&lt;/code&gt; and &lt;code&gt;hashed_secret&lt;/code&gt; go in the database, while the
plaintext &lt;code&gt;secret&lt;/code&gt; is only stored in memory. We need code in our
AuthenticationToken model to generate all three of these values, and
also code to perform the actual authentication by finding a token that
matches the &lt;code&gt;secret&lt;/code&gt; and &lt;code&gt;secret_id&lt;/code&gt; from a user request.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll make the
AuthenticationToken generate all three of these values before
validation any time they don&amp;rsquo;t exist, which ensures that they&amp;rsquo;ll exist
on newly-created tokens after saving. Here&amp;rsquo;s the code for our
AuthenticationToken model:&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"securerandom"&lt;/span&gt;
&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"bcrypt"&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AuthenticationToken&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;belongs_to&lt;/span&gt; &lt;span class="ss"&gt;:authenticatable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;polymorphic: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;validates&lt;/span&gt; &lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;presence: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;uniqueness: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;validates&lt;/span&gt; &lt;span class="ss"&gt;:hashed_secret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;presence: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;before_validation&lt;/span&gt; &lt;span class="ss"&gt;:generate_secret_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;unless&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="ss"&gt;:secret_id&lt;/span&gt;
  &lt;span class="n"&gt;before_validation&lt;/span&gt; &lt;span class="ss"&gt;:generate_secret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;unless&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="ss"&gt;:secret&lt;/span&gt;
  &lt;span class="kp"&gt;attr_accessor&lt;/span&gt; &lt;span class="ss"&gt;:secret&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;find_authenticated&lt;/span&gt; &lt;span class="n"&gt;credentials&lt;/span&gt;
    &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;secret_id: &lt;/span&gt;&lt;span class="n"&gt;credentials&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nf"&gt;first&lt;/span&gt;
    &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;has_secret?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;credentials&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;has_secret?&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;
    &lt;span class="no"&gt;BCrypt&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hashed_secret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kp"&gt;private&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_secret_id&lt;/span&gt;
    &lt;span class="k"&gt;begin&lt;/span&gt;
      &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;secret_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;class&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;exists?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;secret_id: &lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;secret_id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_secret&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;secret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;urlsafe_base64&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hashed_secret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;BCrypt&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;create&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;cost: &lt;/span&gt;&lt;span class="n"&gt;cost&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;cost&lt;/span&gt;
    &lt;span class="no"&gt;Rails&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;env&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;test?&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;To authenticate, we&amp;rsquo;ll just search for a token matching the given
&lt;code&gt;secret_id&lt;/code&gt;, and then ask bcrypt to compare its &lt;code&gt;hashed_secret&lt;/code&gt; against
the secret provided by the user. The result will be the matching
AuthenticationToken object, or nil if there&amp;rsquo;s no match. Next, we just
need a couple of private methods to generate the secret and secret_id.&lt;/p&gt;

&lt;p&gt;We also have code to generate the all the necessary secret-related
values at validation time. This ensures that when we save a
newly-created AuthenticationToken, it will have all the necessary
values (the plaintext &lt;code&gt;secret&lt;/code&gt; will only be in memory, while the
&lt;code&gt;secret_id&lt;/code&gt; and &lt;code&gt;hashed_secret&lt;/code&gt; will get saved to the database).  We can
use Ruby&amp;rsquo;s handy SecureRandom to generate both the secret and the
&lt;code&gt;secret_id&lt;/code&gt;, and we&amp;rsquo;ll give the &lt;code&gt;secret&lt;/code&gt; considerably more entropy to make
sure it&amp;rsquo;s secure. We also insert a little extra-paranoid protection
when generating the &lt;code&gt;secret_id&lt;/code&gt;, to make sure it&amp;rsquo;s unique.&lt;/p&gt;

&lt;p&gt;Why does the &lt;code&gt;secret_id&lt;/code&gt; need any entropy at all? In fact, why not just
use AuthenticationToken&amp;rsquo;s existing &lt;code&gt;id&lt;/code&gt; field? Because although it
suits our purposes by being unique, it also gives away information
about the chronological sequence of token creation and the total
number of tokens in our database. This information may or may not be
useful to potential attackers, but in general it&amp;rsquo;s not the business of
anyone who hasn&amp;rsquo;t authenticated.&lt;/p&gt;

&lt;p&gt;Finally, we confront the API performance issue by carefully choosing
the &lt;code&gt;cost&lt;/code&gt; value to pass in to bcrypt. In test mode, we want to use
the smallest value possible so our automated tests can generate and
authenticate tokens quickly. In production we&amp;rsquo;re starting with the
same default of 10 that Devise uses, but we&amp;rsquo;re free to turn it up for
extra security, or down for faster performance. If we turn it down all
the way to 1 for a negligible performance overhead in production,
we&amp;rsquo;ll still have hashed secrets that are much more secure than plain
text.&lt;/p&gt;

&lt;h4&gt;The Controller&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s common with or without Devise to have a &lt;code&gt;current_user&lt;/code&gt; method in
the controller to represent the logged-in user. We&amp;rsquo;ll follow that
convention and add a &lt;code&gt;current_token&lt;/code&gt; method that holds an
AuthenticationToken, if any is currently authenticated. Then the
controller can check for a &lt;code&gt;current_token&lt;/code&gt; on each request, and
automatically log in any associated user. Here&amp;rsquo;s the code to be added
to ApplicationController:&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ApplicationController&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActionController&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;before_filter&lt;/span&gt; &lt;span class="ss"&gt;:authenticate_from_token&lt;/span&gt;

  &lt;span class="kp"&gt;protected&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;authenticate_from_token&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;try&lt;/span&gt; &lt;span class="ss"&gt;:authenticatable&lt;/span&gt;
      &lt;span class="n"&gt;sign_in&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;authenticatable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;store: &lt;/span&gt;&lt;span class="kp"&gt;false&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;current_token&lt;/span&gt;
    &lt;span class="no"&gt;AuthenticationToken&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;find_authenticated&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
      &lt;span class="ss"&gt;secret: &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
      &lt;span class="ss"&gt;secret_id: &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;})&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;current_token&lt;/code&gt; method includes the logic to find the credentials
being submitted by the user. Here, it&amp;rsquo;s set up to recognize
credentials in either the params or the request headers, although that
policy can easily be customized.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;authenticate_from_token&lt;/code&gt; method might also need to be modified
for different applications. The example above assumes Devise is
present, so it uses Devise&amp;rsquo;s &lt;code&gt;sign_in&lt;/code&gt; method to sign in the user and
set &lt;code&gt;current_user&lt;/code&gt;. The &lt;code&gt;store: false&lt;/code&gt; option prevents the user&amp;rsquo;s
identity from being saved in the session, so subsequent API requests
will still require the &lt;code&gt;secret&lt;/code&gt; and &lt;code&gt;secret_id&lt;/code&gt;. This code could be
easily modified to directly set &lt;code&gt;current_user&lt;/code&gt;, or whatever is most
appropriate for an application not using Devise.&lt;/p&gt;

&lt;h4&gt;Communicating Secrets to the User&lt;/h4&gt;

&lt;p&gt;Each user has to know his/her secret_id and secret in order to log
in. How to best communicate these credentials to users depends on the
needs of your particular application. Some applications might allow
users to view their API credentials from a web page. Others might only
send the credentials via email, or in response to other API calls
(such as those that create new user accounts).&lt;/p&gt;

&lt;p&gt;Note, however, that since we&amp;rsquo;re hashing our secrets, the only time we
can show the user a secret is at the time it is first created. There&amp;rsquo;s
no way for a user to come back later and ask for a secret that&amp;rsquo;s been
forgotten. This is better for security, but it needs to be anticipated
by the UI design of our application. Some services handle this by
requiring the API token to be replaced (and any existing token
invalidated) any time the user needs to retrieve it, but our decoupled
design allows you to create multiple valid tokens for each user if you
want. Whatever solution you plan to implement, you can use the console
to verify that it&amp;rsquo;s easy to retrieve the credentials of a
newly-created token:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;$ rake db:migrate &amp;amp;&amp;amp; rails console
&amp;gt; token = AuthenticationToken.create; [token.secret_id, token.secret]
 ...
 =&amp;gt; ["42aa20ee181a2201", "hWIW41mF1wvvN_3TC5ObaFXBrdWPdEJBWjnGduuGwmA"]
&lt;/pre&gt;

&lt;p&gt;But when the same token is freshly loaded from the database,
its secret is unknown.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&amp;gt; token = AuthenticationToken.find(token.id); [token.secret_id, token.secret]
 ...
 =&amp;gt; ["42aa20ee181a2201", nil]
&lt;/pre&gt;

&lt;h4&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;The above code comes with no guarantee of security, and you should use
it (along with any modifications you make to suit your own
application) with caution, especially because it hasn&amp;rsquo;t been vetted by
real-world use. But since it&amp;rsquo;s built around a core of bcrypt, and it
aims for a decoupled, maintainable object-oriented design, it should
be a good starting point for a post-Devise solution for token
authentication. Try it on for size, and let me know what you think.&lt;/p&gt;
</content>
  </entry>
</feed>
