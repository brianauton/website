<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brian Auton's Blog</title>
  <subtitle>Software Developer and Consultant</subtitle>
  <id>http://www.brianauton.com/</id>
  <link href="http://www.brianauton.com/"/>
  <link href="http://www.brianauton.com/feed.xml"/>
  <updated>2014-12-10T19:00:00-05:00</updated>
  <author>
    <name>Brian Auton</name>
  </author>
  <entry>
    <title>Rails and Web Components Part 1&amp;#58; Adding Polymer to a Rails App</title>
    <link rel="alternate" href="http://www.brianauton.com/posts/rails-web-components-polymer-part-1.html"/>
    <id>http://www.brianauton.com/posts/rails-web-components-polymer-part-1.html</id>
    <published>2014-12-10T19:00:00-05:00</published>
    <updated>2014-12-11T16:16:15-05:00</updated>
    <author>
      <name>Brian Auton</name>
    </author>
    <summary type="html">&lt;p&gt;My horizons were expanded a little bit by Dane O&amp;#39;Connor&amp;rsquo;s recent talk on &lt;a href="http://webcomponents.org/"&gt;web components&lt;/a&gt; and
&lt;a href="https://www.polymer-project.org/"&gt;Polymer&lt;/a&gt; at &lt;a href="http://www.meetup.com/Software-as-Craft-Philadelphia/"&gt;Software As Craft Philadelphia&lt;/a&gt;. Not knowing much about web components, I didn&amp;rsquo;t
realize there was such an elegant way to encapsulate the related JavaScript, CSS, and HTML for
a single piece of a website&amp;rsquo;s behavior without having to manipulate global state. That&amp;rsquo;s a
huge improvement to the state of the art for front-end development, and I immediately wondered
how easy it would be to start including this stuff in some of my current Rails projects.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re not already familiar with the basic idea of web components and how they work from a
purely front-end perspective, take a look at the &lt;a href="https://www.polymer-project.org/docs/start/everything.html"&gt;introduction on the Polymer site&lt;/a&gt;. Otherwise,
read on to learn about the mostly painless process I used to get web components up and running
in an existing Rails app.
</summary>
    <content type="html">&lt;p&gt;My horizons were expanded a little bit by Dane O&amp;#39;Connor&amp;rsquo;s recent talk on &lt;a href="http://webcomponents.org/"&gt;web components&lt;/a&gt; and
&lt;a href="https://www.polymer-project.org/"&gt;Polymer&lt;/a&gt; at &lt;a href="http://www.meetup.com/Software-as-Craft-Philadelphia/"&gt;Software As Craft Philadelphia&lt;/a&gt;. Not knowing much about web components, I didn&amp;rsquo;t
realize there was such an elegant way to encapsulate the related JavaScript, CSS, and HTML for
a single piece of a website&amp;rsquo;s behavior without having to manipulate global state. That&amp;rsquo;s a
huge improvement to the state of the art for front-end development, and I immediately wondered
how easy it would be to start including this stuff in some of my current Rails projects.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re not already familiar with the basic idea of web components and how they work from a
purely front-end perspective, take a look at the &lt;a href="https://www.polymer-project.org/docs/start/everything.html"&gt;introduction on the Polymer site&lt;/a&gt;. Otherwise,
read on to learn about the mostly painless process I used to get web components up and running
in an existing Rails app.
&lt;/p&gt;

&lt;h3&gt;Asset Pipeline Support&lt;/h3&gt;

&lt;p&gt;In pursuit of a simple solution, I considered bypassing the asset pipeline and dumping some
components into the public directory. But it turns out that a single gem addition can teach
the asset pipeline how to package up web components just like other assets. &lt;a href="https://github.com/ahuth/emcee"&gt;The Emcee gem&lt;/a&gt;
seems to be really good at this, so I started by adding &lt;code&gt;emcee&lt;/code&gt; to my Gemfile and updating the
bundle. Next I ran Emcee&amp;rsquo;s generator to create a few useful files:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;rails g emcee:install
&lt;/pre&gt;

&lt;p&gt;That gave me a brand new manifest file for web components, similar to the familiar
application.js and application.css manifests, except this one&amp;rsquo;s an html file. Emcee also added
a reference to the new manifest file to my application layout. At this point I&amp;rsquo;m free to add
my own components to &lt;code&gt;app/assets/components&lt;/code&gt;, and they&amp;rsquo;ll get served up by the asset pipeline.&lt;/p&gt;

&lt;h3&gt;Installing a Component&lt;/h3&gt;

&lt;p&gt;But before diving into custom components, I wanted to see a stock component working in my app
as a proof of concept. The Polymer project includes &lt;a href="https://www.polymer-project.org/docs/start/usingelements.html"&gt;lots of components&lt;/a&gt;, including a full set
that implement Google&amp;rsquo;s &lt;a href="http://www.google.com/design/spec/material-design/introduction.html#"&gt;material design guidelines&lt;/a&gt;. I could download a component along with
each of its dependencies from the Polymer site and unzip them all into
&lt;code&gt;app/assets/components&lt;/code&gt;, but this process can easily be automated with a front-end package
manager like &lt;a href="http://bower.io/"&gt;Bower&lt;/a&gt;, which is Polymer&amp;rsquo;s recommended way to install components.&lt;/p&gt;

&lt;p&gt;I wasn&amp;rsquo;t already using Bower to manage any of my Rails assets, but it&amp;rsquo;s easy to install with
&lt;a href="http://nodejs.org/"&gt;node&lt;/a&gt; and &lt;a href="http://npmjs.org/"&gt;npm&lt;/a&gt;. Installing those isn&amp;rsquo;t covered here, but they&amp;rsquo;re widely supported and should
be easy to set up on any modern system that doesn&amp;rsquo;t have them already. Since I already had
node and npm, installing bower was easy:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;npm install -g bower
&lt;/pre&gt;

&lt;p&gt;After that, any Polymer component and all its dependencies can be installed with a single
bower command. Emcee already created a .bowerrc file to tell Bower to put packages in
&lt;code&gt;vendor/assets/components&lt;/code&gt;, where they&amp;rsquo;ll be available to the asset pipeline but separate from
any custom components I might add to &lt;code&gt;app/assets/components&lt;/code&gt;. I decided to install a stock
Polymer component that implements a material-styled button:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;bower install Polymer/paper-button
&lt;/pre&gt;

&lt;p&gt;I also added it to the manifest at &lt;code&gt;app/assets/components/application.html&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;*= require paper-button/paper-button
&lt;/pre&gt;

&lt;h3&gt;Using the New Component&lt;/h3&gt;

&lt;p&gt;Now the installation is done, and I&amp;rsquo;m free to drop the component&amp;rsquo;s custom HTML element (in
this case, &lt;code&gt;&amp;lt;paper-button&amp;gt;&lt;/code&gt;) into any view in my app, and the component will show up on the
page. Or at least it will show up in Chrome (more on browser compatibility in a moment).&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&amp;lt;paper-button raised&amp;gt;My Button Text&amp;lt;/paper-button&amp;gt;
&lt;/pre&gt;

&lt;p&gt;After adding this code to a view, I have a button with its own &amp;ldquo;paper&amp;rdquo; styling and fancy
JavaScript behavior, and all this complexity is fully encapsulated behind the &lt;code&gt;&amp;lt;paper-button&amp;gt;&lt;/code&gt;
tag. The button has complex CSS styles that look very different from the rest of my app, but I
didn&amp;rsquo;t have to change any of my existing CSS or selector names to avoid conflicts. The button
uses a web font that I didn&amp;rsquo;t previously have in my project, but I didn&amp;rsquo;t have to install that
either. And I don&amp;rsquo;t know or care if the button depends on a hundred different JavaScript
libraries, because I didn&amp;rsquo;t have to separately include them in my project. If you think this
sounds like a refreshingly modern way to manage front-end dependencies, you&amp;rsquo;re starting to
understand why web components are a big deal.&lt;/p&gt;

&lt;h3&gt;Supporting More Browsers&lt;/h3&gt;

&lt;p&gt;But at this point the component still didn&amp;rsquo;t show up in any browser other than
Chrome. Luckily, Polymer provides a library of JavaScript workarounds that extend web
component support to browsers that haven&amp;rsquo;t yet implemented all the necessary HTML features
natively.&lt;/p&gt;

&lt;p&gt;The library is called &lt;a href="http://webcomponents.org/polyfills/"&gt;webcomponents.js&lt;/a&gt;, and Bower already installed it as one of
paper-button&amp;rsquo;s dependencies. I first tried including this library by referencing it in
&lt;code&gt;app/assets/javascripts/application.js&lt;/code&gt;. But this broke the &lt;a href="https://github.com/teampoltergeist/poltergeist"&gt;Poltergeist-driven&lt;/a&gt; acceptance
tests in my test suite, because PhantomJS doesn&amp;rsquo;t get along well with webcomponents.js. So as
a temporary fix to keep my test suite passing, I had to include webcomponents.js in a way that
let me turn it off in test mode. I ended up adding a separate include tag to my application
layout:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&amp;lt;%= javascript_include_tag "webcomponentsjs/webcomponents" unless Rails.env.test? %&amp;gt;
&lt;/pre&gt;

&lt;p&gt;And then I needed to add it as an asset to be separately precompiled. This went in
&lt;code&gt;config/initializers/assets.rb&lt;/code&gt; with the rest of my asset pipeline configuration.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;Rails.application.config.assets.precompile &amp;lt;&amp;lt; "webcomponentsjs/webcomponents.js"
&lt;/pre&gt;

&lt;p&gt;After that, my paper-button looked perfect in Firefox and Mobile Safari as well.&lt;/p&gt;

&lt;h3&gt;Testing Issues and Future Topics&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s a problem that web components don&amp;rsquo;t yet work well with PhantomJS (and probably other
similar testing tools), because I will definitely need acceptance-level testing of web
components once my app starts to really depend on them. And once I start creating custom
components of any real complexity, I&amp;rsquo;ll also need to unit test them, which is something the
Polymer team is &lt;a href="https://github.com/Polymer/web-component-tester"&gt;actively working on&lt;/a&gt;. I&amp;rsquo;ll revisit these testing issues in a future post.&lt;/p&gt;

&lt;p&gt;Also in a future post, I&amp;rsquo;ll look into the best ways for web components to interact with data
that lives on the server side of a Rails app. But for now, if you&amp;rsquo;ve been following along,
you&amp;rsquo;re ready to further explore the components described in the Polymer docs, as well as their
tutorials on how to make your own custom components. Until next time, enjoy your trip into the
future of web development.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>The Best Commit Messages Are Just One Line</title>
    <link rel="alternate" href="http://www.brianauton.com/posts/best-commit-messages-one-line.html"/>
    <id>http://www.brianauton.com/posts/best-commit-messages-one-line.html</id>
    <published>2014-11-11T19:00:00-05:00</published>
    <updated>2014-12-11T15:39:06-05:00</updated>
    <author>
      <name>Brian Auton</name>
    </author>
    <summary type="html">&lt;p&gt;If you want a simple way to make your commit messages more effective, try strictly limiting
them to one line. Many developers and teams try to be helpful by packing extra detail into the
body of each commit message whenever possible. But this detail takes extra time to write and
to read, and it rarely adds any value. Here are some things I&amp;rsquo;ve often seen wasting space in
the body of a multi-line commit message.
</summary>
    <content type="html">&lt;p&gt;If you want a simple way to make your commit messages more effective, try strictly limiting
them to one line. Many developers and teams try to be helpful by packing extra detail into the
body of each commit message whenever possible. But this detail takes extra time to write and
to read, and it rarely adds any value. Here are some things I&amp;rsquo;ve often seen wasting space in
the body of a multi-line commit message.
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Specific descriptions of changes to the code.&lt;/strong&gt; Anyone who wants more detail about your
commit after seeing it as a one-liner in the commit history will end up looking at the
individual file changes in addition to the commit message. So in a commit whose main purpose
was to “add a User model”, they&amp;rsquo;ll know that you also “added a mirgration” and “added a unit
test.”  There&amp;rsquo;s no need to list those redundant details in the commit message. And there&amp;rsquo;s
always the chance that you&amp;rsquo;ll make a mistake or leave something out, and the resulting
misleading message is worse than no message at all.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notes about follow-on tasks or things that still need to be done.&lt;/strong&gt; &lt;em&gt;“Still need to add
acceptance tests”.&lt;/em&gt; &lt;em&gt;“This should be factored out into a new class”.&lt;/em&gt; If those tasks are
required to finish the current feature, just do them as subsequent commits before you call the
feature done. If they&amp;rsquo;re vital tasks but not part of the current feature, add them to the
project&amp;rsquo;s issue tracking software. After all, no one is combing commit messages for stuff to
do, so you can&amp;rsquo;t leave the completion of a vital feature up to the chance that someone will
notice the reminder in your commit message. If they&amp;rsquo;re not vital, save everyone&amp;rsquo;s time by
leaving them out.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Full URL to the issue tracker software.&lt;/strong&gt; I like commit messages that start with a brief
reference to the issue number itself, mainly because that&amp;rsquo;s a great way to visually group
related commits together. But it becomes tedious to paste a full URL into the commit message
body once you realize that no one has a good reason to follow it. Developers working on the
issue will already have it close at hand. Stakeholders verifying that a feature is complete or
a bug is fixed are looking at the application behavior, not at the commit history. And no one
looking back to your code in the future needs to be distracted by discussions of external
requirements that are now outdated, or alternate approaches that were ultimately abandoned.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Discussion of requirements for the feature.&lt;/strong&gt; &lt;em&gt;“Designer asked for a darker navbar, so we&amp;rsquo;re
trying #000066.”&lt;/em&gt; This is like linking to the issue, but worse, because it pulls irrelevant
discussion out of the issue tracker and directly into the codebase. The commit message should
focus on what was actually done to the code, not what should have been done.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Long descriptions.&lt;/strong&gt; Eliminating all the offenders above leaves what&amp;rsquo;s really important: the
high-level description of what you changed. If this is too long to fit in one line, the
problem may be that your commit is too big. Multiple sentences (as well as multiple clauses
separated by “and”) usually signify separate concerns that should have been committed
separately. If you&amp;rsquo;ve squashed an entire feature branch into a single commit before merging,
stop doing that. Let your commit messages tell a story about how you solved the problem in
individual steps.&lt;/p&gt;

&lt;p&gt;Use appropriate commit sizes and practice revising your wording and eliminating the dead
weight. You can get almost any commit message down to just one line, and each one will add
highly-focused value to the project and make the best use of everyone&amp;rsquo;s time.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rails Token Authentication Without Devise</title>
    <link rel="alternate" href="http://www.brianauton.com/posts/token-authentication-devise.html"/>
    <id>http://www.brianauton.com/posts/token-authentication-devise.html</id>
    <published>2014-05-03T20:00:00-04:00</published>
    <updated>2014-12-03T21:18:06-05:00</updated>
    <author>
      <name>Brian Auton</name>
    </author>
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;A popular solution for token-based authentication in Rails has been
retired, and the most common replacements leave some security issues
unaddressed.  Here&amp;rsquo;s a solution with a clean and maintainable design.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Anyone working on a modern Rails application is probably familiar with
&lt;a href="https://github.com/plataformatec/devise"&gt;Devise&lt;/a&gt;. It&amp;rsquo;s by far the &lt;a href="https://www.ruby-toolbox.com/categories/rails_authentication"&gt;most popular&lt;/a&gt; drop-in solution for handling
authentication of the username and password variety. Anyone who also
needs to offer token-based authentication (maybe in order to offer a
REST API), might be accustomed to using Devise for this too, through
its handy &lt;code&gt;token_authenticatable&lt;/code&gt; feature.&lt;/p&gt;

&lt;p&gt;Those developers might be dismayed, as I was, to find that
&lt;code&gt;token_authenticatable&lt;/code&gt; has been &lt;a href="https://github.com/plataformatec/devise/issues/2616"&gt;removed&lt;/a&gt; from recent versions of
Devise. They might be further dismayed to find that the only solution
that has any sort of consensus as a replacement seems dubious for a
couple of different reasons.
</summary>
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;A popular solution for token-based authentication in Rails has been
retired, and the most common replacements leave some security issues
unaddressed.  Here&amp;rsquo;s a solution with a clean and maintainable design.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Anyone working on a modern Rails application is probably familiar with
&lt;a href="https://github.com/plataformatec/devise"&gt;Devise&lt;/a&gt;. It&amp;rsquo;s by far the &lt;a href="https://www.ruby-toolbox.com/categories/rails_authentication"&gt;most popular&lt;/a&gt; drop-in solution for handling
authentication of the username and password variety. Anyone who also
needs to offer token-based authentication (maybe in order to offer a
REST API), might be accustomed to using Devise for this too, through
its handy &lt;code&gt;token_authenticatable&lt;/code&gt; feature.&lt;/p&gt;

&lt;p&gt;Those developers might be dismayed, as I was, to find that
&lt;code&gt;token_authenticatable&lt;/code&gt; has been &lt;a href="https://github.com/plataformatec/devise/issues/2616"&gt;removed&lt;/a&gt; from recent versions of
Devise. They might be further dismayed to find that the only solution
that has any sort of consensus as a replacement seems dubious for a
couple of different reasons.
&lt;/p&gt;

&lt;h4&gt;The Problem and Solutions So Far&lt;/h4&gt;

&lt;p&gt;Why was &lt;code&gt;token_authenticatable&lt;/code&gt; removed? According to the &lt;a href="http://blog.plataformatec.com.br/2013/08/devise-3-1-now-with-more-secure-defaults/"&gt;official
blog post&lt;/a&gt;, the concern was raised that authentication tokens (along
with other non-password secrets like password reset tokens) have
traditionally been stored in plain text by Devise, and as such are
vulnerable to timing attacks. This is true, and they are also
vulnerable to brute-force cracking attempts, as well as being
completely exposed in the event of unauthorized read access to the
database.&lt;/p&gt;

&lt;p&gt;Of course, all these issues have been long known as they pertain to
the traditional user passwords that are at the core of Devise&amp;rsquo;s
functionality. That&amp;rsquo;s why Devise has always run these passwords
through a &lt;a href="http://throwingfire.com/storing-passwords-securely/#notpasswordhashes"&gt;password hash function&lt;/a&gt; before storing them in the
database. A good password hash function, such as the widely-trusted
&lt;a href="https://github.com/codahale/bcrypt-ruby"&gt;bcrypt&lt;/a&gt; that Devise uses by default, solves all these problems at
once, and there&amp;rsquo;s very little reason not to use one when handling any
data that is used as a password.&lt;/p&gt;

&lt;p&gt;As of version 3.1, Devise began protecting most of its non-password
secrets by hashing them with bcrypt as well. But hashing an
authentication token that&amp;rsquo;s intended for repeated use presents a
couple of extra challenges. For one, if bcrypt authentication needs to
be performed on every request to an API, the extra performance penalty
could result in a significant slowdown. Also, the user experience
around API-enabled websites is often designed so that a user can
retreive their API token if they&amp;rsquo;ve forgotten it, which is impossible
if the token is only stored as a hash.&lt;/p&gt;

&lt;p&gt;The Devise team decided not to impose a single solution to these
problems on everyone who uses Devise for token
authentication. Instead, they removed the feature and linked to a
&lt;a href="https://gist.github.com/josevalim/fb706b1e933ef01e4fb6"&gt;gist&lt;/a&gt; that presents two different code samples as starting points for
a custom solution to the problem. One of these is equivalent to
Devise&amp;rsquo;s old behavior, and the other one adds some protection against
timing attacks at the expense of changing the application API and
requiring additional info from the users who are authenticating via
token.&lt;/p&gt;

&lt;p&gt;On the plus side, this approach encourages users to think through the
solution as it applies to their individual applications, rather than
blindly copying code. On the other hand, it still amounts to the
strongly discouraged practice of &lt;a href="http://security.stackexchange.com/a/18198"&gt;rolling one&amp;rsquo;s own&lt;/a&gt; security
code. Furthermore, the provided &amp;ldquo;secure&amp;rdquo; option only addresses the
timing attack problem, while continuing to store authentication
secrets in plain text and thus remaining exposed to the other
vulnerabilities.&lt;/p&gt;

&lt;h4&gt;An Alternate Solution&lt;/h4&gt;

&lt;p&gt;When facing these issues recently on a new API-focused application, I
found some opportunities to improve on the solution suggested by the
Devise team. Most importantly, I thought it was worth finding a way
around the performance and token-recoverability issues mentioned
above, to gain the benefit of using bcrypt to hash authentication
tokens. In addition to protecting against more vulnerabilities than
just timing attacks, this also means that while the overall security
architecture is hand-rolled, the most critical hashing and comparison
code is handed off to a trusted library.&lt;/p&gt;

&lt;p&gt;In addition, I ended up with a solution that has a more modular and
maintainable design for the data model, and that&amp;rsquo;s easily adaptable to
applications not using Devise. Let&amp;rsquo;s walk through the solution below;
feel free to make use of it and make suggestions for further
improvement.&lt;/p&gt;

&lt;h4&gt;Storing the Secret&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s common practice to add additional authentication-related fields
to the application&amp;rsquo;s User model, but let&amp;rsquo;s defy that trend and create
a separate AuthenticationToken model. This will avoid conflicting with
any fields already on User, but more importantly, it decouples the
User model from the token authentication logic. This is very good for
maintainability, because changes to the authentication scheme won&amp;rsquo;t
require changes to the User model (or models, as the case may be).&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also good because it&amp;rsquo;s flexible enough to allow multiple
AuthenticationTokens for each User. Later we&amp;rsquo;ll discuss one reason why
we might want that. But for now, it means that we can&amp;rsquo;t rely on a
User-specific piece of data (such as email address, as in the Devise
example) to uniquely identify the token value (which we&amp;rsquo;ll call the
&lt;code&gt;secret&lt;/code&gt;) that we hashed with bcrypt. So we&amp;rsquo;ll need some kind of
searchable unique token identifier stored in plain text, and we&amp;rsquo;ll
call that the &lt;code&gt;secret_id&lt;/code&gt;. AWS users are used to keeping track of both
a &amp;ldquo;key id&amp;rdquo; and a &amp;ldquo;secret key&amp;rdquo; for exactly this reason.&lt;/p&gt;

&lt;p&gt;As long as we&amp;rsquo;re aiming for a modular design, we should also make the
user-to-token relationship polymorphic, so we&amp;rsquo;ll only need one token
model in applications that have multiple user models (to which we&amp;rsquo;ll
give the general label &lt;code&gt;authenticatable&lt;/code&gt;). With all that in mind,
here&amp;rsquo;s the migration for the token model:&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CreateAuthenticationTokens&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Migration&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;change&lt;/span&gt;
    &lt;span class="n"&gt;create_table&lt;/span&gt; &lt;span class="ss"&gt;:authentication_tokens&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
      &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;references&lt;/span&gt; &lt;span class="ss"&gt;:authenticatable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;polymorphic: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
      &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="ss"&gt;:secret_id&lt;/span&gt;
      &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="ss"&gt;:hashed_secret&lt;/span&gt;
      &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;timestamps&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;add_index&lt;/span&gt; &lt;span class="ss"&gt;:authentication_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;unique: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;h4&gt;The Model&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;secret_id&lt;/code&gt; and &lt;code&gt;hashed_secret&lt;/code&gt; go in the database, while the
plaintext &lt;code&gt;secret&lt;/code&gt; is only stored in memory. We need code in our
AuthenticationToken model to generate all three of these values, and
also code to perform the actual authentication by finding a token that
matches the &lt;code&gt;secret&lt;/code&gt; and &lt;code&gt;secret_id&lt;/code&gt; from a user request.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll make the
AuthenticationToken generate all three of these values before
validation any time they don&amp;rsquo;t exist, which ensures that they&amp;rsquo;ll exist
on newly-created tokens after saving. Here&amp;rsquo;s the code for our
AuthenticationToken model:&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"securerandom"&lt;/span&gt;
&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"bcrypt"&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AuthenticationToken&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;belongs_to&lt;/span&gt; &lt;span class="ss"&gt;:authenticatable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;polymorphic: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;validates&lt;/span&gt; &lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;presence: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;uniqueness: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;validates&lt;/span&gt; &lt;span class="ss"&gt;:hashed_secret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;presence: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;before_validation&lt;/span&gt; &lt;span class="ss"&gt;:generate_secret_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;unless&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="ss"&gt;:secret_id&lt;/span&gt;
  &lt;span class="n"&gt;before_validation&lt;/span&gt; &lt;span class="ss"&gt;:generate_secret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;unless&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="ss"&gt;:secret&lt;/span&gt;
  &lt;span class="kp"&gt;attr_accessor&lt;/span&gt; &lt;span class="ss"&gt;:secret&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;find_authenticated&lt;/span&gt; &lt;span class="n"&gt;credentials&lt;/span&gt;
    &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;secret_id: &lt;/span&gt;&lt;span class="n"&gt;credentials&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nf"&gt;first&lt;/span&gt;
    &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;has_secret?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;credentials&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;has_secret?&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;
    &lt;span class="no"&gt;BCrypt&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hashed_secret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kp"&gt;private&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_secret_id&lt;/span&gt;
    &lt;span class="k"&gt;begin&lt;/span&gt;
      &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;secret_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;class&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;exists?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;secret_id: &lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;secret_id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_secret&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;secret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;urlsafe_base64&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hashed_secret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;BCrypt&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;create&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;cost: &lt;/span&gt;&lt;span class="n"&gt;cost&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;cost&lt;/span&gt;
    &lt;span class="no"&gt;Rails&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;env&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;test?&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;To authenticate, we&amp;rsquo;ll just search for a token matching the given
&lt;code&gt;secret_id&lt;/code&gt;, and then ask bcrypt to compare its &lt;code&gt;hashed_secret&lt;/code&gt; against
the secret provided by the user. The result will be the matching
AuthenticationToken object, or nil if there&amp;rsquo;s no match. Next, we just
need a couple of private methods to generate the secret and secret_id.&lt;/p&gt;

&lt;p&gt;We also have code to generate the all the necessary secret-related
values at validation time. This ensures that when we save a
newly-created AuthenticationToken, it will have all the necessary
values (the plaintext &lt;code&gt;secret&lt;/code&gt; will only be in memory, while the
&lt;code&gt;secret_id&lt;/code&gt; and &lt;code&gt;hashed_secret&lt;/code&gt; will get saved to the database).  We can
use Ruby&amp;rsquo;s handy SecureRandom to generate both the secret and the
&lt;code&gt;secret_id&lt;/code&gt;, and we&amp;rsquo;ll give the &lt;code&gt;secret&lt;/code&gt; considerably more entropy to make
sure it&amp;rsquo;s secure. We also insert a little extra-paranoid protection
when generating the &lt;code&gt;secret_id&lt;/code&gt;, to make sure it&amp;rsquo;s unique.&lt;/p&gt;

&lt;p&gt;Why does the &lt;code&gt;secret_id&lt;/code&gt; need any entropy at all? In fact, why not just
use AuthenticationToken&amp;rsquo;s existing &lt;code&gt;id&lt;/code&gt; field? Because although it
suits our purposes by being unique, it also gives away information
about the chronological sequence of token creation and the total
number of tokens in our database. This information may or may not be
useful to potential attackers, but in general it&amp;rsquo;s not the business of
anyone who hasn&amp;rsquo;t authenticated.&lt;/p&gt;

&lt;p&gt;Finally, we confront the API performance issue by carefully choosing
the &lt;code&gt;cost&lt;/code&gt; value to pass in to bcrypt. In test mode, we want to use
the smallest value possible so our automated tests can generate and
authenticate tokens quickly. In production we&amp;rsquo;re starting with the
same default of 10 that Devise uses, but we&amp;rsquo;re free to turn it up for
extra security, or down for faster performance. If we turn it down all
the way to 1 for a negligible performance overhead in production,
we&amp;rsquo;ll still have hashed secrets that are much more secure than plain
text.&lt;/p&gt;

&lt;h4&gt;The Controller&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s common with or without Devise to have a &lt;code&gt;current_user&lt;/code&gt; method in
the controller to represent the logged-in user. We&amp;rsquo;ll follow that
convention and add a &lt;code&gt;current_token&lt;/code&gt; method that holds an
AuthenticationToken, if any is currently authenticated. Then the
controller can check for a &lt;code&gt;current_token&lt;/code&gt; on each request, and
automatically log in any associated user. Here&amp;rsquo;s the code to be added
to ApplicationController:&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ApplicationController&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActionController&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;before_filter&lt;/span&gt; &lt;span class="ss"&gt;:authenticate_from_token&lt;/span&gt;

  &lt;span class="kp"&gt;protected&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;authenticate_from_token&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_token&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;try&lt;/span&gt; &lt;span class="ss"&gt;:authenticatable&lt;/span&gt;
      &lt;span class="n"&gt;sign_in&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;authenticatable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;store: &lt;/span&gt;&lt;span class="kp"&gt;false&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;current_token&lt;/span&gt;
    &lt;span class="no"&gt;AuthenticationToken&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;find_authenticated&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
      &lt;span class="ss"&gt;secret: &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
      &lt;span class="ss"&gt;secret_id: &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:secret_id&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;})&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;current_token&lt;/code&gt; method includes the logic to find the credentials
being submitted by the user. Here, it&amp;rsquo;s set up to recognize
credentials in either the params or the request headers, although that
policy can easily be customized.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;authenticate_from_token&lt;/code&gt; method might also need to be modified
for different applications. The example above assumes Devise is
present, so it uses Devise&amp;rsquo;s &lt;code&gt;sign_in&lt;/code&gt; method to sign in the user and
set &lt;code&gt;current_user&lt;/code&gt;. The &lt;code&gt;store: false&lt;/code&gt; option prevents the user&amp;rsquo;s
identity from being saved in the session, so subsequent API requests
will still require the &lt;code&gt;secret&lt;/code&gt; and &lt;code&gt;secret_id&lt;/code&gt;. This code could be
easily modified to directly set &lt;code&gt;current_user&lt;/code&gt;, or whatever is most
appropriate for an application not using Devise.&lt;/p&gt;

&lt;h4&gt;Communicating Secrets to the User&lt;/h4&gt;

&lt;p&gt;Each user has to know his/her secret_id and secret in order to log
in. How to best communicate these credentials to users depends on the
needs of your particular application. Some applications might allow
users to view their API credentials from a web page. Others might only
send the credentials via email, or in response to other API calls
(such as those that create new user accounts).&lt;/p&gt;

&lt;p&gt;Note, however, that since we&amp;rsquo;re hashing our secrets, the only time we
can show the user a secret is at the time it is first created. There&amp;rsquo;s
no way for a user to come back later and ask for a secret that&amp;rsquo;s been
forgotten. This is better for security, but it needs to be anticipated
by the UI design of our application. Some services handle this by
requiring the API token to be replaced (and any existing token
invalidated) any time the user needs to retrieve it, but our decoupled
design allows you to create multiple valid tokens for each user if you
want. Whatever solution you plan to implement, you can use the console
to verify that it&amp;rsquo;s easy to retrieve the credentials of a
newly-created token:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;$ rake db:migrate &amp;amp;&amp;amp; rails console
&amp;gt; token = AuthenticationToken.create; [token.secret_id, token.secret]
 ...
 =&amp;gt; ["42aa20ee181a2201", "hWIW41mF1wvvN_3TC5ObaFXBrdWPdEJBWjnGduuGwmA"]
&lt;/pre&gt;

&lt;p&gt;But when the same token is freshly loaded from the database,
its secret is unknown.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&amp;gt; token = AuthenticationToken.find(token.id); [token.secret_id, token.secret]
 ...
 =&amp;gt; ["42aa20ee181a2201", nil]
&lt;/pre&gt;

&lt;h4&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;The above code comes with no guarantee of security, and you should use
it (along with any modifications you make to suit your own
application) with caution, especially because it hasn&amp;rsquo;t been vetted by
real-world use. But since it&amp;rsquo;s built around a core of bcrypt, and it
aims for a decoupled, maintainable object-oriented design, it should
be a good starting point for a post-Devise solution for token
authentication. Try it on for size, and let me know what you think.&lt;/p&gt;
</content>
  </entry>
</feed>
